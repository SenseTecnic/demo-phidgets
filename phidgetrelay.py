"""
Copyright (c) 2012 Sense Tecnic Systems Inc.

@author:        Benn Mapes

Description:    This module is meant to test out different sensors attached
                to the InterfaceKit (the big board with all the inputs for 
                sensors). If everything (Phidget's Python library) is installed 
                properly and the Phidgets folder(with Devices and Events) is in 
                the same project as this script, it should all run and you
                should be able to see all the outputs of the sensors as their
                values change. Thats all this script is for but you can also 
                play with it to learn how the Phigets library works.
"""

import Queue #To store events
from threading import Thread, Condition #For sensor listener thread
import time #for sleeping thread

#TODO: move processing to processor so we don't have to import these names (duh)
from Processors import *

#Phidets modules from the Phidgets library
from Phidgets.PhidgetException import PhidgetException
from Phidgets.Devices.InterfaceKit import InterfaceKit


#This is the Configuration module which defines all the configuration constants,
# the main one used in this module is 'port' which has sensor info for each input
# such as {enabled, name, topic}. 
import Configuration

#client that sends data to senseTecnic if you want to add that functionallity.
import sensetecnic


# Create a Condition object to handle critical sections
# such as locking the thread when getting data
cond = Condition()

# Class to store all events generated by the sensors/ports
# Events are stored like [sensor_id, [data]], where [data]
# is the array of tuples (field, value) that gets uploaded
# to sensetecnic.
event_queue = Queue.Queue(0)
    

""" EVENT HANDLER CALLBACK FUNCTIONS """
# I hope the names of the functions speak for themselves

def device_attached (event):
    attached = event.device
    print "Device %i attached." % (attached.getSerialNum())
    return 0

def device_detached (event):
    detached = event.device
    print "Device %i Detached." % (detached.getSerialNum())
    return 0

def device_error (event):
    print "Phidget Error %i: %s" % (event.eCode, event.description)
    return 0

#When the input changes, called at the beginning when polling inputs.
#You can view this by unplugging the USB from the computer and the plugging it back in.
def interfacekit_input (event):
    input_id = "INPUT_" + str (event.index)
    input = Configuration.port[input_id]
    cond.acquire ()    # Acquire lock
    if input["enabled"]:
        fields = [("data", input["data"]), ("state", event.state),
                  ("time", time.time())]
        if input["topic"] is not None:
            Events.event_queue.put([input_id, fields])
        print "%s: %i" % (input["data"], event.state)
    else:
        print "%s: %s" % (input, "Disabled")
    cond.release()
    return 0

def interfacekit_sensor (event):

  sensor_id = "SENSOR_" + str (event.index)
  sensor = Configuration.port[sensor_id]
  sensor_name = sensor['sensor'];

  cond.acquire()  # Acquire lock

  if sensor["enabled"]:
    global event_queue
    processors = sensor["processors"]
    value = event.value

    if processors is not None and len (processors) > 0:
      for p in processors:
        if value is None:
          break

        stmt = p[0:(p.find ("(") + 1)] + "'" + sensor_id + "', " + str (value) + ", " + p[(p.find ("(") + 1):]

        value = eval (stmt)

    if value is not None and sensor["sensor"] is not None:
      # it is important that these fields follow the SenseTecnic schema
      # for sensors that send events
      fields = [("value", value)]
      event_queue.put ([sensor_name, fields])

  cond.release ()
  return 0    

#This thread monitors the sensor inputs/outputs
#This is what is running the whole time and deals with
# the events as they come up.

#NOTE: This thread blocks the main thread from raising a KeyboardInterrupt (CTRL-C)
class ListeningThread(Thread):
    
    def __init__(self):
        Thread.__init__(self)
        
    def run(self):
        #Continuously loop, waiting for events to occur
        while True:
            event = event_queue.get()
            # send to wotkit
            sensetecnic.sendData(event[0], Configuration.SERV_USER, Configuration.SERV_PASS, event[1])

            print event        
    
    
# Creates an InterfaceKit object which is used to communicate with the interface board.
ifk = InterfaceKit()

if __name__ == "__main__":
    try:
        # Set event handler callbacks to fire our own methods
        ifk.setOnAttachHandler(device_attached)
        ifk.setOnDetachHandler(device_detached)
        ifk.setOnErrorhandler(device_error)
        ifk.setOnInputChangeHandler(interfacekit_input)
        ifk.setOnSensorChangeHandler(interfacekit_sensor)

    except PhidgetException, e:
        print "Set event handlers error. Phidget Exception %i: %s" % \
              (e.code, e.message)
        print "Exiting..."
        exit(1)
        
    print "Opening phidget objects..."

    try:
        # Open connection for phidget attachment
        ifk.openPhidget()
    except PhidgetException, e:
        print "Opening phidget error. Phidget Exception %i: %s" % \
              (e.code, e.message)
        print "Exiting..."
        exit(1)
        
    print "Waiting for phidget attachments..."

    try:
        # Wait for attachment of InterfaceKit phidget
        ifk.waitForAttach(10000)
    except PhidgetException, e:
        print "Phidget Exception %i: %s" % (e.code, e.message)
        try:
            ifk.closePhidget()
            exit(1)
        except PhidgetException, e:
            print "Closing phidget error. Phidget Exception %i: %s" % \
                  (e.code, e.message)
            print "Exiting..."
            exit(1)
    try:
        # Create a worker thread to send events to OSGiBroker
        thr = ListeningThread()
        # Start thread
        thr.start()
        thr.join()
    except KeyboardInterrupt:
        exit()
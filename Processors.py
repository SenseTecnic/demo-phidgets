"""
Copyright (c) 2010 Sense Tecnic Systems Inc.

@author:        Jake Lin

Description:    This module contains all the processors available to be
                used for the data generated by Phidgets.
"""

import time
import types

""" DATA PROCESSORS """

"""
Coverts the raw value from a temperature sensor to the specified
temperature scale. If no scale is provided, Celsius scale will be used.

temperature(sensor, value[, scale]) -> temperature
"""
def temperature(sensor, value, scale=None):
	if not isinstance(scale, types.StringTypes):
		print "Scale provided is not valid"
		return None

	celsius = ((float(value)/1000.0)*250.0)-50.0

	if scale is None or scale.lower() == "c":
		return celsius
	else:
		if scale.lower() == "f":
			fahrenheit = (1.8*celsius)+32.0
			return fahrenheit
		if scale.lower() == "k":
			kelvin = celsius+273.15
			return kelvin
	
	print "Requested scale is not available"
	return None

""" END of DATA PROCESSORS """


""" STATISTIC PROCESSORS """

"""
Calculates the average of accumulated data. If size is provided, the
average of the last 'size' data stored are used for calculating the
average. If size is not provided or 0, the overall average is
returned. If size is < 0

average(sensor, value[, size]) -> average
"""
def average(sensor, value, size=0):
	var = sensor + "_average"
	if not isinstance(size, types.IntType):
		print "Sample size provided is not valid"
		return None
	
	if not globals().has_key(var):
		globals()[var] = []
	
	globals()[var].append(value)

	sum = 0
	average = 0

	if size == 0:
		for val in globals()[var]:
			sum += val
		average = sum/len(globals()[var])
		return average
	else:
		if len(globals()[var]) > size:
			itr = 0
			for val in reversed(globals()[var]):
				if itr > size:
					break
				sum += val
				itr += 1
			average = sum/size
			return average
	
	return None


"""
Calculates the average of all data collected within a window of time.
If period is not specified, then the original value is returned.

average_window(sensor, value[, period]) -> average
"""
def average_window(sensor, value, period=0):
	var = sensor + "_averageWindow"
	if not isinstance(period, (types.IntType, types.FloatType)):
		print "Period provided is not valid"
		return None
		
	if not globals().has_key(var):
		globals()[var] = ([], time.time())
	
	globals()[var][0].append(value)
	
	if time.time()-globals()[var][1] > period:
		sum = 0.0
		average = 0.0
		for val in globals()[var][0]:
			sum += val
		average = sum/len(globals()[var][0])
		
		globals()[var] = ([], time.time())
		return average

	return None


"""
Finds the maximum value obtained in all data received. If previous is
provided, then only the previous number of data specified will be used.
If previous is negative, the first 'previous' number of data will be 
used to determine the max.

maximum(sensor, value[, previous]) -> maximum
"""
def maximum(sensor, value, previous=0):
	var = sensor + "_all"
	if not isinstance(previous, types.IntType):
		print "Previous provided is not valid"
		return None
	
	if value is None:
		return None
	
	if not globals().has_key(var):
		globals()[var] = []

	globals()[var].append(value)

	if previous > 0:
		sublist = globals()[var][-previous:]
		return max(sublist)
	elif previous < 0:
		sublist = globals()[var][0:previous]
		return max(sublist)
	else:
		return max(globals()[var])
		

"""
Finds the minimum value obtained in all data received. If previous is
provided, then only the previous number of data specified will be used.
If previous is negative, the first 'previous' number of data will be 
used to determine the min.

minimum(sensor, value[, previous]) -> minimum
"""
def minimum(sensor, value, previous=0):
	var = sensor + "_all"
	if not isinstance(previous, types.IntType):
		print "Previous provided is not valid"
		return None

	if value is None:
		return None

	if not globals().has_key(var):
		globals()[var] = []

	globals()[var].append(value)

	if previous > 0:
		sublist = globals()[var][-previous:]
		return min(sublist)
	elif previous < 0:
		sublist = globals()[var][0:previous]
		return min(sublist)
	else:
		return min(globals()[var])

""" END of STATISTIC PROCESSORS """


""" OTHER PROCESSORS """

"""
Checks if the value provided has a difference in change that is greater
than or equal to a limit. A percentage (given as a string) can be used 
for the limit (eg '10%').

enough_difference(sensor, value[, limit]) -> value
"""
def enough_difference(sensor, value, limit=0):
	var = sensor + "_enoughDiff"
	if not isinstance(limit, (types.IntType, types.FloatType, \
							  types.StringTypes)):
		print "Limit provided is not valid"
		return None
	
	if not globals().has_key(var):
		globals()[var] = value
		return None
	
	change = abs(globals()[var]-value)
	
	if isinstance(limit, (types.IntType, types.FloatType)):
		if limit == 0 or change >= limit:
			globals()[var] = value
			return value
	elif isinstance(limit, types.StringTypes):
		percent = float(limit[0:limit.find("%")])/100
		if change >= globals()[var]*percent:
			globals()[var] = value
			return value

	return None


"""
Puts a pause period where all data received will be discarded.

pause(sensor, value[, period]) -> value
"""
def pause(sensor, value, period=0):
	var = sensor + "_pause"
	if not isinstance(period, (types.IntType, types.FloatType)):
		print "Period provided is not valid"
		return None
		
	if not globals().has_key(var):
		globals()[var] = time.time()
		return value
		
	if period > 0:
		if time.time()-globals()[var] < period:
			return None
	
	globals()[var] = time.time()
	return value


"""
Checks if a value is above or below a certain threshold.

pass_threshold(sensor, value[, min, max]) -> value
"""
def pass_threshold(sensor, value, min=0, max=0):
	if not isinstance(min, (types.IntType, types.FloatType)):
		print "Min threshold provided is not valid"
		return None

	if not isinstance(max, (types.IntType, types.FloatType)):
		print "Max threshold provided is not valid"
		return None	
	
	if value <= min or value >= max:
		return value
	else:
		return None
